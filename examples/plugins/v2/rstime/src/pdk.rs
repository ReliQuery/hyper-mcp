// THIS FILE WAS GENERATED BY `xtp-rust-bindgen`. DO NOT EDIT.

#![allow(non_snake_case)]
#![allow(unused_macros)]
use extism_pdk::*;

#[allow(unused)]
fn panic_if_key_missing() -> ! {
    panic!("missing key");
}

pub(crate) mod internal {
    pub(crate) fn return_error(e: extism_pdk::Error) -> i32 {
        let err = format!("{:?}", e);
        let mem = extism_pdk::Memory::from_bytes(&err).unwrap();
        unsafe {
            extism_pdk::extism::error_set(mem.offset());
        }
        -1
    }
}

#[allow(unused)]
macro_rules! try_input {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(x) => x,
            Err(e) => return internal::return_error(e),
        }
    }};
}

#[allow(unused)]
macro_rules! try_input_json {
    () => {{
        let x = extism_pdk::input();
        match x {
            Ok(extism_pdk::Json(x)) => x,
            Err(e) => return internal::return_error(e),
        }
    }};
}

use base64_serde::base64_serde_type;

base64_serde_type!(Base64Standard, base64::engine::general_purpose::STANDARD);

mod exports {
    use super::*;

    #[no_mangle]
    pub extern "C" fn call_tool() -> i32 {
        let ret = crate::call_tool(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn complete() -> i32 {
        let ret = crate::complete(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn get_prompt() -> i32 {
        let ret = crate::get_prompt(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn list_prompts() -> i32 {
        let ret = crate::list_prompts(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn list_resource_templates() -> i32 {
        let ret = crate::list_resource_templates(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn list_resources() -> i32 {
        let ret = crate::list_resources(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn list_tools() -> i32 {
        let ret = crate::list_tools(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn on_roots_list_changed() -> i32 {
        let ret = crate::on_roots_list_changed(try_input_json!()).and_then(extism_pdk::output);

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }

    #[no_mangle]
    pub extern "C" fn read_resource() -> i32 {
        let ret = crate::read_resource(try_input_json!())
            .and_then(|x| extism_pdk::output(extism_pdk::Json(x)));

        match ret {
            Ok(()) => 0,
            Err(e) => internal::return_error(e),
        }
    }
}

pub mod types {
    use super::*;

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Annotations {
        /// Intended audience for the resource
        #[serde(rename = "audience")]
        pub audience: Vec<types::Role>,

        /// Last modified timestamp for the resource
        #[serde(rename = "lastModified")]
        pub last_modified: chrono::DateTime<chrono::Utc>,

        /// Priority level indicating the importance of the resource
        #[serde(rename = "priority")]
        pub priority: f32,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct AudioContent {
        /// Optional additional metadata about the content block
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Optional content annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Base64-encoded audio data
        #[serde(rename = "data")]
        pub data: String,

        /// MIME type of the audio (e.g. 'audio/mpeg')
        #[serde(rename = "mimeType")]
        pub mime_type: String,

        #[serde(rename = "type")]
        pub r#type: types::AudioType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum AudioType {
        #[default]
        #[serde(rename = "audio")]
        Audio,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct BlobResourceContents {
        /// Optional additional metadata about the blob resource
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Base64-encoded binary data of the resource
        #[serde(rename = "blob")]
        pub blob: String,

        /// MIME type of the binary content (e.g. 'application/pdf')
        #[serde(rename = "mimeType")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub mime_type: Option<String>,

        /// URI of the resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct BooleanSchema {
        /// Optional default value
        #[serde(rename = "default")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub default: Option<bool>,

        /// Description of the boolean input
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::BooleanType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum BooleanType {
        #[default]
        #[serde(rename = "boolean")]
        Boolean,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CallToolRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,

        #[serde(rename = "request")]
        pub request: types::CallToolRequestParam,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CallToolRequestParam {
        /// Arguments to pass to the tool
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub arguments: Option<serde_json::Map<String, serde_json::Value>>,

        /// The name of the tool to call
        #[serde(rename = "name")]
        pub name: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CallToolResult {
        /// Optional additional metadata about the tool call result
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Array of TextContent, ImageContent, AudioContent, EmbeddedResource, or ResourceLinks representing the result
        #[serde(rename = "content")]
        pub content: Vec<serde_json::Map<String, serde_json::Value>>,

        /// Whether the tool call ended in an error. If not set, defaults to false.
        #[serde(rename = "isError")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub is_error: Option<bool>,

        /// Optional structured JSON result from the tool
        #[serde(rename = "structuredContent")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub structured_content: Option<serde_json::Map<String, serde_json::Value>>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CompleteRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,

        #[serde(rename = "request")]
        pub request: types::CompleteRequestParam,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CompleteRequestParam {
        #[serde(rename = "argument")]
        pub argument: types::CompleteRequestParamArgument,

        /// Optional completion context with previously-resolved arguments
        #[serde(rename = "context")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub context: Option<serde_json::Map<String, serde_json::Value>>,

        /// Reference to either a PromptReference or ResourceTemplateReference
        #[serde(rename = "ref")]
        pub r#ref: serde_json::Map<String, serde_json::Value>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CompleteRequestParamArgument {
        /// Name of the argument
        #[serde(rename = "name")]
        pub name: String,

        /// Current value to complete
        #[serde(rename = "value")]
        pub value: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CompleteResult {
        #[serde(rename = "completion")]
        pub completion: types::CompleteResultCompletion,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CompleteResultCompletion {
        /// Whether there are more completions available
        #[serde(rename = "hasMore")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub has_more: Option<bool>,

        /// Total number of available completions
        #[serde(rename = "total")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub total: Option<i64>,

        /// Array of completion values (max 100 items)
        #[serde(rename = "values")]
        pub values: Vec<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CreateElicitationRequestParamWithTimeout {
        /// Message to present to the user
        #[serde(rename = "message")]
        pub message: String,

        #[serde(rename = "requestedSchema")]
        pub requested_schema: types::Schema,

        /// Optional timeout in milliseconds
        #[serde(rename = "timeout")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub timeout: Option<i64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CreateElicitationResult {
        #[serde(rename = "action")]
        pub action: types::CreateElicitationResultAction,

        /// Form data submitted by user (only present when action is accept)
        #[serde(rename = "content")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub content: Option<serde_json::Map<String, serde_json::Value>>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum CreateElicitationResultAction {
        #[default]
        #[serde(rename = "accept")]
        Accept,
        #[serde(rename = "decline")]
        Decline,
        #[serde(rename = "cancel")]
        Cancel,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CreateMessageRequestParam {
        #[serde(rename = "includeContext")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub include_context: Option<types::CreateMessageRequestParamIncludeContext>,

        /// Maximum tokens to sample
        #[serde(rename = "maxTokens")]
        pub max_tokens: i64,

        /// Conversation messages of of TextContent, ImageContent or AudioContent
        #[serde(rename = "messages")]
        pub messages: Vec<serde_json::Map<String, serde_json::Value>>,

        /// Preferences for model selection
        #[serde(rename = "modelPreferences")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub model_preferences: Option<types::ModelPreferences>,

        /// Stop sequences
        #[serde(rename = "stopSequences")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub stop_sequences: Option<Vec<String>>,

        /// Optional system prompt
        #[serde(rename = "systemPrompt")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub system_prompt: Option<String>,

        /// Sampling temperature
        #[serde(rename = "temperature")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub temperature: Option<f64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum CreateMessageRequestParamIncludeContext {
        #[default]
        #[serde(rename = "none")]
        None,
        #[serde(rename = "thisServer")]
        ThisServer,
        #[serde(rename = "allServers")]
        AllServers,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct CreateMessageResult {
        /// One of TextContent, ImageContent or AudioContent
        #[serde(rename = "content")]
        pub content: serde_json::Map<String, serde_json::Value>,

        /// Name of the model used
        #[serde(rename = "model")]
        pub model: String,

        #[serde(rename = "role")]
        pub role: types::Role,

        /// Optional reason sampling stopped
        #[serde(rename = "stopReason")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub stop_reason: Option<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct EmbeddedResource {
        /// Optional additional metadata about the embedded resource
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Optional resource annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// The embedded TextResourceContents or BlobResourceContents
        #[serde(rename = "resource")]
        pub resource: serde_json::Map<String, serde_json::Value>,

        #[serde(rename = "type")]
        pub r#type: types::ResourceType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct EnumSchema {
        /// Description of the enum input
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Array of allowed string values
        #[serde(rename = "enum")]
        pub r#enum: Vec<String>,

        /// Optional array of human-readable names for the enum values
        #[serde(rename = "enumNames")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub enum_names: Option<Vec<String>>,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::StringType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct GetPromptRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,

        #[serde(rename = "request")]
        pub request: types::GetPromptRequestParam,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct GetPromptRequestParam {
        /// Arguments for templating the prompt
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub arguments: Option<serde_json::Map<String, serde_json::Value>>,

        /// Name of the prompt to retrieve
        #[serde(rename = "name")]
        pub name: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct GetPromptResult {
        /// Optional description of the prompt
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Array of prompt messages
        #[serde(rename = "messages")]
        pub messages: Vec<types::PromptMessage>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ImageContent {
        /// Optional additional metadata about the content block
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Optional content annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Base64-encoded image data
        #[serde(rename = "data")]
        pub data: String,

        /// MIME type of the image (e.g. 'image/png')
        #[serde(rename = "mimeType")]
        pub mime_type: String,

        #[serde(rename = "type")]
        pub r#type: types::ImageType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum ImageType {
        #[default]
        #[serde(rename = "image")]
        Image,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListPromptsRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListPromptsResult {
        /// Array of available prompts
        #[serde(rename = "prompts")]
        pub prompts: Vec<types::Prompt>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListResourceTemplatesRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListResourceTemplatesResult {
        /// Optional cursor for pagination
        #[serde(rename = "nextCursor")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub next_cursor: Option<String>,

        /// Array of resource templates
        #[serde(rename = "resourceTemplates")]
        pub resource_templates: Vec<types::ResourceTemplate>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListResourcesRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListResourcesResult {
        /// Array of available resources
        #[serde(rename = "resources")]
        pub resources: Vec<types::Resource>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListRootsResult {
        /// Array of root directories/resources
        #[serde(rename = "roots")]
        pub roots: Vec<types::Root>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListToolsRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ListToolsResult {
        /// Array of available tools
        #[serde(rename = "tools")]
        pub tools: Vec<types::Tool>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum LoggingLevel {
        #[default]
        #[serde(rename = "debug")]
        Debug,
        #[serde(rename = "info")]
        Info,
        #[serde(rename = "notice")]
        Notice,
        #[serde(rename = "warning")]
        Warning,
        #[serde(rename = "error")]
        Error,
        #[serde(rename = "critical")]
        Critical,
        #[serde(rename = "alert")]
        Alert,
        #[serde(rename = "emergency")]
        Emergency,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct LoggingMessageNotificationParam {
        /// Data to log (any JSON-serializable type)
        #[serde(rename = "data")]
        pub data: serde_json::Map<String, serde_json::Value>,

        #[serde(rename = "level")]
        pub level: types::LoggingLevel,

        /// Optional logger name
        #[serde(rename = "logger")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub logger: Option<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ModelHint {
        /// Suggested model name or family
        #[serde(rename = "name")]
        pub name: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ModelPreferences {
        /// Priority for cost (0-1)
        #[serde(rename = "costPriority")]
        pub cost_priority: f32,

        /// Model name hints
        #[serde(rename = "hints")]
        pub hints: Vec<types::ModelHint>,

        /// Priority for intelligence (0-1)
        #[serde(rename = "intelligencePriority")]
        pub intelligence_priority: f32,

        /// Priority for speed (0-1)
        #[serde(rename = "speedPriority")]
        pub speed_priority: f32,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct NumberSchema {
        /// Description of the number input
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Maximum value
        #[serde(rename = "maximum")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub maximum: Option<f64>,

        /// Minimum value
        #[serde(rename = "minimum")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub minimum: Option<f64>,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::NumberType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum NumberType {
        #[default]
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "integer")]
        Integer,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum ObjectType {
        #[default]
        #[serde(rename = "object")]
        Object,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PluginNotificationContext {
        /// Additional metadata about the notification
        #[serde(rename = "_meta")]
        pub _meta: serde_json::Map<String, serde_json::Value>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PluginRequestContext {
        /// Additional metadata about the request
        #[serde(rename = "_meta")]
        pub _meta: serde_json::Map<String, serde_json::Value>,

        /// Unique identifier for this request
        #[serde(rename = "id")]
        pub id: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ProgressNotificationParam {
        /// Optional progress message describing current operation
        #[serde(rename = "message")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub message: Option<String>,

        /// The progress thus far
        #[serde(rename = "progress")]
        pub progress: f64,

        /// A token identifying the progress context
        #[serde(rename = "progressToken")]
        pub progress_token: String,

        /// Optional total units of work
        #[serde(rename = "total")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub total: Option<f64>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Prompt {
        /// Optional prompt arguments
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub arguments: Option<Vec<types::PromptArgument>>,

        /// Description of what the prompt does
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Unique name of the prompt
        #[serde(rename = "name")]
        pub name: String,

        /// Human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PromptArgument {
        /// Description of the argument
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Name of the argument
        #[serde(rename = "name")]
        pub name: String,

        /// Whether this argument is required
        #[serde(rename = "required")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub required: Option<bool>,

        /// Human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PromptMessage {
        /// One of TextContent, ImageContent, AudioContent, EmbeddedResource, or ResourceLink
        #[serde(rename = "content")]
        pub content: serde_json::Map<String, serde_json::Value>,

        #[serde(rename = "role")]
        pub role: types::Role,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct PromptReference {
        /// Name of the prompt
        #[serde(rename = "name")]
        pub name: String,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::PromptReferenceType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum PromptReferenceType {
        #[default]
        #[serde(rename = "prompt")]
        Prompt,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ReadResourceRequest {
        #[serde(rename = "context")]
        pub context: types::PluginRequestContext,

        #[serde(rename = "request")]
        pub request: types::ReadResourceRequestParam,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ReadResourceRequestParam {
        /// URI of the resource to read
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ReadResourceResult {
        /// Array of TextResourceContents or BlobResourceContents
        #[serde(rename = "contents")]
        pub contents: Vec<serde_json::Map<String, serde_json::Value>>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Resource {
        /// Optional resource annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Description of the resource
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// MIME type of the resource
        #[serde(rename = "mimeType")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub mime_type: Option<String>,

        /// Human-readable name
        #[serde(rename = "name")]
        pub name: String,

        /// Size in bytes
        #[serde(rename = "size")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub size: Option<i64>,

        /// Human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        /// URI of the resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ResourceLink {
        /// Optional additional metadata about the resource link
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Optional resource annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Optional description of the resource
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// Optional MIME type of the resource
        #[serde(rename = "mimeType")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub mime_type: Option<String>,

        /// Optional human-readable name
        #[serde(rename = "name")]
        pub name: String,

        /// Optional size in bytes
        #[serde(rename = "size")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub size: Option<i64>,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::ResourceLinkType,

        /// URI of the resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum ResourceLinkType {
        #[default]
        #[serde(rename = "resource_link")]
        ResourceLink,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum ResourceReferenceType {
        #[default]
        #[serde(rename = "resource")]
        Resource,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ResourceTemplate {
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Description of the template
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        /// MIME type for resources matching this template
        #[serde(rename = "mimeType")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub mime_type: Option<String>,

        /// Human-readable name
        #[serde(rename = "name")]
        pub name: String,

        /// Human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        /// RFC 6570 URI template pattern
        #[serde(rename = "uriTemplate")]
        pub uri_template: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ResourceTemplateReference {
        #[serde(rename = "type")]
        pub r#type: types::ResourceReferenceType,

        /// URI or URI template pattern of the resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum ResourceType {
        #[default]
        #[serde(rename = "resource")]
        Resource,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ResourceUpdatedNotificationParam {
        /// URI of the updated resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum Role {
        #[default]
        #[serde(rename = "assistant")]
        Assistant,
        #[serde(rename = "user")]
        User,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Root {
        /// Optional human-readable name
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub name: Option<String>,

        /// URI of the root (typically file://)
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Schema {
        /// A map of StringSchema, NumberSchema, BooleanSchema or EnumSchema definitions (no nesting)
        #[serde(rename = "properties")]
        pub properties: serde_json::Map<String, serde_json::Value>,

        /// Required property names
        #[serde(rename = "required")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub required: Option<Vec<String>>,

        #[serde(rename = "type")]
        pub r#type: types::ObjectType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct StringSchema {
        /// Description of the string input
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        #[serde(rename = "format")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub format: Option<types::StringSchemaFormat>,

        /// Maximum length of the string
        #[serde(rename = "maxLength")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub max_length: Option<i64>,

        /// Minimum length of the string
        #[serde(rename = "minLength")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub min_length: Option<i64>,

        /// Optional human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,

        #[serde(rename = "type")]
        pub r#type: types::StringType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum StringSchemaFormat {
        #[default]
        #[serde(rename = "email")]
        Email,
        #[serde(rename = "uri")]
        Uri,
        #[serde(rename = "date")]
        Date,
        #[serde(rename = "date_time")]
        Datetime,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum StringType {
        #[default]
        #[serde(rename = "string")]
        String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct TextContent {
        /// Optional additional metadata about the content block
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// Optional content annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// The text content
        #[serde(rename = "text")]
        pub text: String,

        #[serde(rename = "type")]
        pub r#type: types::TextType,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct TextResourceContents {
        /// Optional additional metadata about the text resource
        #[serde(rename = "_meta")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub _meta: Option<serde_json::Map<String, serde_json::Value>>,

        /// MIME type of the text content (e.g. 'text/plain')
        #[serde(rename = "mimeType")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub mime_type: Option<String>,

        /// Text content of the resource
        #[serde(rename = "text")]
        pub text: String,

        /// URI of the resource
        #[serde(rename = "uri")]
        pub uri: String,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub enum TextType {
        #[default]
        #[serde(rename = "text")]
        Text,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct Tool {
        /// Optional tool annotations
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub annotations: Option<types::Annotations>,

        /// Description of what the tool does
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub description: Option<String>,

        #[serde(rename = "inputSchema")]
        pub input_schema: types::ToolSchema,

        /// Unique name of the tool
        #[serde(rename = "name")]
        pub name: String,

        #[serde(rename = "outputSchema")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub output_schema: Option<types::ToolSchema>,

        /// Human-readable title
        #[serde(rename = "title")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub title: Option<String>,
    }

    #[derive(
        Default,
        Debug,
        Clone,
        serde::Serialize,
        serde::Deserialize,
        extism_pdk::FromBytes,
        extism_pdk::ToBytes,
    )]
    #[encoding(Json)]
    pub struct ToolSchema {
        /// Schema properties
        #[serde(rename = "properties")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub properties: Option<serde_json::Map<String, serde_json::Value>>,

        /// Required properties
        #[serde(rename = "required")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[serde(default)]
        pub required: Option<Vec<String>>,

        #[serde(rename = "type")]
        pub r#type: types::ObjectType,
    }
}

mod raw_imports {
    use super::*;
    #[host_fn]
    extern "ExtismHost" {

        pub(crate) fn create_elicitation(
            input: Json<types::CreateElicitationRequestParamWithTimeout>,
        ) -> Json<types::CreateElicitationResult>;

        pub(crate) fn create_message(
            input: Json<types::CreateMessageRequestParam>,
        ) -> Json<types::CreateMessageResult>;

        pub(crate) fn list_roots() -> Json<types::ListRootsResult>;

        pub(crate) fn notify_logging_message(input: Json<types::LoggingMessageNotificationParam>);

        pub(crate) fn notify_progress(input: Json<types::ProgressNotificationParam>);

        pub(crate) fn notify_prompt_list_changed();

        pub(crate) fn notify_resource_list_changed();

        pub(crate) fn notify_resource_updated(input: Json<types::ResourceUpdatedNotificationParam>);

        pub(crate) fn notify_tool_list_changed();

    }
}

/// create_elicitation Request user input through the client's elicitation interface.
///
/// Plugins can use this to ask users for input, decisions, or confirmations. This is useful for interactive plugins that need user guidance during tool execution. Returns the user's response with action and optional form data.
/// It takes input of types::CreateElicitationRequestParamWithTimeout ()
/// And it returns an output types::CreateElicitationResult ()
#[allow(unused)]
pub(crate) fn create_elicitation(
    input: types::CreateElicitationRequestParamWithTimeout,
) -> std::result::Result<types::CreateElicitationResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::create_elicitation(extism_pdk::Json(input))? };

    let extism_pdk::Json(res) = res;

    Ok(res)
}

/// create_message Request message creation through the client's sampling interface.
///
/// Plugins can use this to have the client create messages, typically with AI assistance. This is used when plugins need intelligent text generation or analysis. Returns the generated message with model information.
/// It takes input of types::CreateMessageRequestParam ()
/// And it returns an output types::CreateMessageResult ()
#[allow(unused)]
pub(crate) fn create_message(
    input: types::CreateMessageRequestParam,
) -> std::result::Result<types::CreateMessageResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::create_message(extism_pdk::Json(input))? };

    let extism_pdk::Json(res) = res;

    Ok(res)
}

/// list_roots List the client's root directories or resources.
///
/// Plugins can query this to discover what root resources (typically file system roots) are available on the client side. This helps plugins understand the scope of resources they can access.
/// And it returns an output types::ListRootsResult ()
#[allow(unused)]
pub(crate) fn list_roots() -> std::result::Result<types::ListRootsResult, extism_pdk::Error> {
    let res = unsafe { raw_imports::list_roots()? };

    let extism_pdk::Json(res) = res;

    Ok(res)
}

/// notify_logging_message Send a logging message to the client.
///
/// Plugins use this to report diagnostic, informational, warning, or error messages. The client's logging level determines which messages are processed.
/// It takes input of types::LoggingMessageNotificationParam ()
#[allow(unused)]
pub(crate) fn notify_logging_message(
    input: types::LoggingMessageNotificationParam,
) -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_logging_message(extism_pdk::Json(input))? };

    Ok(res)
}

/// notify_progress Send a progress notification to the client.
///
/// Plugins use this to report progress during long-running operations. This allows clients to display progress bars or status information to users.
/// It takes input of types::ProgressNotificationParam ()
#[allow(unused)]
pub(crate) fn notify_progress(
    input: types::ProgressNotificationParam,
) -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_progress(extism_pdk::Json(input))? };

    Ok(res)
}

/// notify_prompt_list_changed Notify the client that the list of available prompts has changed.
///
/// Plugins should call this when they add, remove, or modify their available prompts. The client will typically refresh its prompt list in response.
#[allow(unused)]
pub(crate) fn notify_prompt_list_changed() -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_prompt_list_changed()? };

    Ok(res)
}

/// notify_resource_list_changed Notify the client that the list of available resources has changed.
///
/// Plugins should call this when they add, remove, or modify their available resources. The client will typically refresh its resource list in response.
#[allow(unused)]
pub(crate) fn notify_resource_list_changed() -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_resource_list_changed()? };

    Ok(res)
}

/// notify_resource_updated Notify the client that a specific resource has been updated.
///
/// Plugins should call this when they modify the contents of a resource. The client can use this to invalidate caches and refresh resource displays.
/// It takes input of types::ResourceUpdatedNotificationParam ()
#[allow(unused)]
pub(crate) fn notify_resource_updated(
    input: types::ResourceUpdatedNotificationParam,
) -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_resource_updated(extism_pdk::Json(input))? };

    Ok(res)
}

/// notify_tool_list_changed Notify the client that the list of available tools has changed.
///
/// Plugins should call this when they add, remove, or modify their available tools. The client will typically refresh its tool list in response.
#[allow(unused)]
pub(crate) fn notify_tool_list_changed() -> std::result::Result<(), extism_pdk::Error> {
    let res = unsafe { raw_imports::notify_tool_list_changed()? };

    Ok(res)
}
